---
title: Global Version Strategy
slug: /strategies/global-version
---

# üåè The Global Version Strategy

:::caution

This document has not yet been updated for Replicache 13.

:::

The Global Version strategy is one of the easiest strategies to implement and the one we recomend most customers start with.

It does have concurrency limits because all pushes server-wide are serialized, and it doesn't support advanced features like incremental sync and read authorization as easily as [row versioning](/strategies/row-version).

:::info

You may wonder why not use a timestamp for the version instead of a counter. While this would scale much better, it is not possible to implement correctly on most servers due to [unreliable clocks](https://www.ics.uci.edu/~cs230/lectures20/distrsyslectureset2-win20.pdf).

:::

## How it Works

### Schema

As with the other strategies, you will need a new entity in your backend database to track Replicache clients:

```yaml
# An instance of the Replicache JS class that has synced with the server.
ReplicacheClient
  # Unique ID for client, generated by Replicache.
  id: string
  # Last mutation processed from this client.
  lastMutationID: uint
```

Also, you'll need a singleton entity (ie a single row in a relational database) to store a global _version_ of the backend database. This version will be incremented on each transaction that changes the synced data:

```yaml
# There should only be one of these system-wide.
ReplicacheVersion
  # Must be incremented in a serializable transaction whenever the database changes.
  version: number
```

Finally, for each entity that will be synced, add two new attributes: `deleted` and `replicacheVersion`. For example, if you are sycing a game, you might have a `Monster` entity in your system:

```yaml
# Monster entity needed to implement your app.
Monster
  # other attributes ...

  # Soft delete. Instead of deleting the document permanently, mark this as true.
  # Note: there are other ways to implement soft deletes, see below.
  deleted: boolean

  # The version of the database this entity was last changed during.
  replicacheVersion: uint
```

### On Push

In an exclusive (serializable) database transaction:

<ol>
  <li>Read the <code>prevVersion</code> for the database, or default to zero if no such version.</li>
  <li>Calculate the <code>nextVersion</code>: <code>prevVersion + 1.</code></li>
  <li>Read the <code>lastMutationID</code> for the calling client. If no such client exists, create one and default its <code>lastMutationID</code> to zero.</li>
  <li>Iterate through the pushed mutations. For each one:
      <ol>
          <li>Validate the mutation ID:
              <ol>
                  <li>If the mutation ID is smaller than the next expected mutation ID, this mutation has been processed. Skip it.</li>
                  <li>If the mutation ID is greater than the next expected mutation ID, there has been a critical error on either the client or server. This client can no longer sync. Log an error, abort transaction, exit push, and return HTTP 400 to client.</li>
              </ol>
          </li>
          <li>Process the mutation. Make whatever changes necessary to the backend database.
            <ul>
              <li>For any entity updated, set the <code>version</code> attribute of the entity to <code>nextVersion</code>.</li>
              <li>For any entity deleted, set the <code>deleted</code> attribute to <code>true</code> and the <code>version</code> attribute to <code>nextVersion</code>.</li>
            </ul>
          </li>
          <li>Update the <code>lastMutationID</code> for the calling client.</li>
      </ol>
  </li>
  <li>Update the global <code>version</code> entity to <code>nextVersion</code>.</li>
  <li>Commit the transaction.</li>
</ol>

:::caution

It is important that the push happen in a serialized transaction, and that both `lastMutationID` and `ReplicacheVersion` are updated atomically as part of this transaction. If this does not happen, clients can receive incorrect results. In particular, in Postgres, do not use a [sequence](https://www.postgresql.org/docs/current/sql-createsequence.html) for the global version, as sequences do not participate in transactions.

:::

:::info

It's a good idea to read the global version ["for update"](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html) if your database supports it. The reason is that this forces the database to wait for an exclusive lock, effectively queueing all pushes ‚Äì sometimes referred to as the [semaphore](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html) pattern.

If you don't do this, but still use serializable transactions, sync will be _correct_ (no data will be lost) but you will see deadlock errors in some databases when pushes and pulls overlap. This is because the database will first get a read lock on the version field, do some work, then later try to upgrade to a write lock, but discover some other transaction already has the write lock.

You can safely retry these deadlocked transactions (in fact Replicache will do this atuomatically), but it's more efficient and a better user experience to just avoid them. Eagerly getting a write lock in push avoid this problem.

:::

### On Pull

In an exclusive (serializable) database transaction:

<ul>
  <li>Read the global <code>version</code> from the database.</li>
  <li>Read the <code>lastMutationID</code> for the calling client, or default to zero if no such client exists.</li>
  <li>Calculate the <code>patch</code> to return. If the request cookie is <code>null</code>:
    <ul>
      <li>Read all entities where <code>deleted = false</code>.</li>
      <li>Create a <em>reset patch</em> - a patch with a <code>clear</code> op followed by <code>put</code> ops for each read entity.</li>
    </ul>
  </li>
  <li>Otherwise:
    <ul>
      <li>Read all entities whose <code>version</code> is greater than the cookie value.</li>
      <li>Create a patch with <code>del</code> ops for each entity where <code>deleted=true</code>, and <code>put</code> ops for other entities.</li>
    </ul>
  </li>
  <li>Return the current global version, the requesting client's <code>lastMutationID</code> (or zero if no such client exists so far), and the patch.</li>
</ul>

## Challenges

### Performance

`GlobalVersion` functions as a global lock. This limits possible concurrency of your backend: if each push takes 20ms then the maximum number of pushes per second for your server is 50.

### Soft Deletes

Soft Deletes are annoying to maintain. All queries to the database need to be aware of the `deleted` column and filter appropriately. There are other ways to implement soft deletes (see below), but they are all at least a little annoying.

### Read Authorization

In many applications, users only have access to a subset of the total data. If a user gains access to an entity they didn't previously have access to, pull should reflect that change. But that won't happen using just the logic described above, because the entity itself didn't change, and therefore its `Version` field won't change.

To correctly implement auth changes with this strategy, you also need to track those auth changes somehow ‚Äî either by having those changes bump the `Version` fields of affected docs, or else by tracking changes to the auth rules themselves with their own `Version` fields.

## Variations

### Early Exit, Batch Size

Just as in the Reset strategy, you can [early exit](./reset#early-exit) the push handler or process mutations in [smaller batches](./reset#batch-size).

### Alternative Soft Delete

There are other ways to implement soft deletes. For example for each entity in your system you can have a separate collection of just deleted entities:

```yaml
# Monster entity needed to implement your app.
Monster
  # other attributes ...

  # note: no `deleted` here

  # The version of the database this entity was last changed during.
  replicacheVersion: uint

# Records monsters that have been deleted
MonsterDeleted
  # The version of the db the monster was deleted at
  replicacheVersion: uint
```

This makes read queries more natural (can just query Monsters collection as normal). But deletes are still weird (must upsert into the `MonstersDeleted` collection).

### Read Authorization

The challenge here is that you must track changes to auth somehow so that its effects can be communicated to clients via pull.

One easy but inefficient way to do this is to bump the `version` field of every entity affected by an auth change. If a user gains access to a directory, bump the version of every

### Partial Sync

TODO

## Examples

The [Get Started Guide](/byob/remote-database) implements the Global Version strategy.
